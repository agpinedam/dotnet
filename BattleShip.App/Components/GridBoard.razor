@using BattleShip.Models
@using Microsoft.AspNetCore.Components.Web

<div class="battleship-grid-container" style="@ContainerStyle">
    @if (Ships != null)
    {
        foreach (var ship in Ships)
        {
                <img src="/images/@GetShipImage(ship.Size)" 
                    draggable="@(IsDraggable ? "true" : "false")"
                    @ondragstart="() => OnDragStart.InvokeAsync(ship)"
                    @onclick="() => { if (IsDraggable) OnRotate.InvokeAsync(ship); }"
                    style="@GetShipStyle(ship)"
                    class="ship-element @(IsDraggable ? "cursor-grab" : "")"
                    alt="Ship" />
        }
    }

    @for (int r = 0; r < GridRows; r++)
    {
        <div class="grid-row">
            @for (int c = 0; c < GridCols; c++)
            {
                var row = r;
                var col = c;
                var cellState = GetCellState(row, col);
                
                <div class="grid-cell @(IsClickable(row, col) ? "cursor-crosshair hover-effect" : "")"
                        ondragover="event.preventDefault();"
                        @ondrop="() => OnDrop.InvokeAsync((row, col))"
                        @onclick="() => HandleClick(row, col)">
                        
                        @if (cellState == CellState.Hit)
                        {
                            <img src="/images/hit.png" alt="Hit" class="img-fluid marker-overlay" />
                        }
                        else if (cellState == CellState.Miss)
                        {
                            <img src="/images/miss.png" alt="Miss" class="img-fluid marker-overlay" />
                        }
                </div>
            }
        </div>
    }
</div>

<style>
    .battleship-grid-container {
        display: flex;
        flex-direction: column;
        position: relative;
        
        /* Aspect Ratio & Sizing Logic */
        aspect-ratio: var(--grid-cols) / var(--grid-rows);
        width: 100%;               /* Try to fill the parent width */
        max-width: var(--max-width); /* But stop at 35px * cols */
        max-height: 100%;          /* And don't overflow parent height */
        min-width: var(--min-width); /* Don't shrink below 15px * cols */
        
        margin: auto;
        
        /* Visuals */
        background-color: #78a7f5;
        border: 2px solid #0a2fa8;
        box-sizing: border-box;
    }

    .grid-row {
        display: flex;
        flex: 1;
        width: 100%;
    }

    .grid-cell {
        flex: 1;
        position: relative;
        border: 1px solid rgba(17, 27, 120, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        margin: 0;
    }

    /* Style for ships */
    .ship-element {
        /* Styles are set inline via GetShipStyle, but we can add common props here */
        pointer-events: auto; 
    }

    /* Utilidades */
    .cursor-grab { cursor: grab; }
    .cursor-grab:active { cursor: grabbing; }
    .cursor-crosshair { cursor: crosshair; }
    
    .hover-effect:hover {
        background-color: rgba(255, 255, 255, 0.3);
    }

    .marker-overlay {
        position: relative;
        z-index: 100;
        pointer-events: none;
    }
</style>

@code {
    [Parameter] public int Rows { get; set; } = 10;
    [Parameter] public int Cols { get; set; } = 10;
    [Parameter] public int CellSize { get; set; } = 35;
    
    // Data
    [Parameter] public char[][]? PlayerGrid { get; set; }
    [Parameter] public bool?[][]? OpponentGrid { get; set; }
    [Parameter] public List<ShipInfo>? Ships { get; set; }
    
    // Behavior
    [Parameter] public bool IsDraggable { get; set; }
    [Parameter] public bool IsInteractive { get; set; } // For attacks
    
    // Events
    [Parameter] public EventCallback<(int Row, int Col)> OnCellClick { get; set; }
    [Parameter] public EventCallback<(int Row, int Col)> OnDrop { get; set; }
    [Parameter] public EventCallback<ShipInfo> OnDragStart { get; set; }
    [Parameter] public EventCallback<ShipInfo> OnRotate { get; set; }

    private int GridRows => PlayerGrid?.Length ?? OpponentGrid?.Length ?? Rows;
    private int GridCols => PlayerGrid?[0].Length ?? OpponentGrid?[0].Length ?? Cols;
    
    private string ContainerStyle => $"--grid-cols: {GridCols}; --grid-rows: {GridRows}; --min-width: {GridCols * 15}px; --max-width: {GridCols * 35}px;";

    private enum CellState { Empty, Hit, Miss }

    private CellState GetCellState(int r, int c)
    {
        if (PlayerGrid != null)
        {
            char cell = PlayerGrid[r][c];
            if (cell == 'X') return CellState.Hit;
            if (cell == 'O') return CellState.Miss;
        }
        else if (OpponentGrid != null)
        {
            bool? cell = OpponentGrid[r][c];
            if (cell == true) return CellState.Hit;
            if (cell == false) return CellState.Miss;
        }
        return CellState.Empty;
    }

    private bool IsClickable(int r, int c)
    {
        if (!IsInteractive) return false;
        if (OpponentGrid != null)
        {
            return OpponentGrid[r][c] == null;
        }
        return false;
    }

    private async Task HandleClick(int r, int c)
    {
        if (IsInteractive)
        {
            await OnCellClick.InvokeAsync((r, c));
        }
    }

    private string GetShipImage(int size) => size switch
    {
        4 => "ship4.png",
        3 => "ship3.png",
        2 => "ship2.png",
        1 => "ship1.png",
        _ => "ship1.png"
    };

    private string GetShipStyle(ShipInfo ship)
    {
        // Percentage-based positioning
        var top = (double)ship.Row / GridRows * 100;
        var left = (double)ship.Col / GridCols * 100;
        
        // Dimensions relative to the grid
        // We assume the ship element is vertical (1xSize) and rotate it if needed
        var width = 100.0 / GridCols;
        var height = (double)ship.Size / GridRows * 100;
        
        var rotation = ship.IsHorizontal ? "rotate(-90deg)" : "none";
        
        // Transform origin: Center of the first cell (top-left of the ship)
        // X: 50% of the width (which is 1 cell wide)
        // Y: Half of one cell height. Since total height is Size cells, 1 cell is (100% / Size). Half is (50% / Size).
        var originY = (0.5 / ship.Size) * 100;
        var transformOrigin = $"50% {originY:0.00}%";

        return $@"
            position: absolute; 
            top: {top:0.00}%; 
            left: {left:0.00}%; 
            width: {width:0.00}%; 
            height: {height:0.00}%; 
            z-index: 10; 
            transform-origin: {transformOrigin};
            transform: {rotation};";
    }
}
